(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{579:function(t,e,a){"use strict";a.r(e);var v=a(4),s=Object(v.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[t._v("#")]),t._v(" Vue")]),t._v(" "),a("h2",{attrs:{id:"v-if-和-v-show-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#v-if-和-v-show-的区别"}},[t._v("#")]),t._v(" v-if 和 v-show 的区别")]),t._v(" "),a("p",[t._v("v-show 的执行是不管条件是真是假，第一次渲染的时候都会被编译出来，也就是标签会被添加到 dom 中，之后切换的时候是通过 display：none 来显示隐藏元素。几乎不会影响什么性能。\nv-if 在首次渲染的时候如果条件为假什么也不操作，页面当作没有这些元素，当条件为真的时候开始局部编译，动态向 dom 添加元素，当条件变为假的时候开始局部编译卸载这些元素\n所以直观的理解就是当我们需要频繁切换元素的显示与隐藏我们可以使用 v-show，如果在运行时条件很少改变，则使用 v-if 较好。")]),t._v(" "),a("p",[t._v("对于管理系统的权限列表的展示，这里可以使用 v-if 来渲染，如果使用到 v-show，对于用户没有的权限，在网页的源码中，仍然能够显示出该权限，如果用 v-if，网页的源码中就不会显示出该权限。")]),t._v(" "),a("h2",{attrs:{id:"key-的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#key-的作用"}},[t._v("#")]),t._v(" key 的作用")]),t._v(" "),a("p",[t._v("给每一个 vnode 一个唯一的 id，依靠这个 id 我们的 diff 操作可以更快速和准确。\n如果我们不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试就地复用或修改相同类型元素的算法\n而当我们使用 key 的时候 Vue 会基于 key 的变化重新排列并移除不存在的元素")]),t._v(" "),a("h2",{attrs:{id:"computed-的和-watch-的区别和-function-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#computed-的和-watch-的区别和-function-的区别"}},[t._v("#")]),t._v(" computed 的和 watch 的区别和 function 的区别")]),t._v(" "),a("p",[t._v("computed 计算属性依赖其他的值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。\nwatch 更多是观察的作用，没有缓存，类似于某些数据的监听回调，每当数据发生变化的时候会执行回调进行后续的操作。所以如果我们需要在数据发生变化的时候执行某些事情我们可以使用 watch")]),t._v(" "),a("p",[t._v("与 function 的区别，computed 有缓存值，只有当 computed 的依赖属性发生变化并且下次获取 computed 值时才会重新计算 computed 的值")]),t._v(" "),a("p",[t._v("使用场景\ncomputed 当我们需要进行数值计算的时候，并且依赖其他数据的时候应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都需要重新计算\nwatch 当我们需要在数据变化的时候执行异步或者开销较大的操作时，应该使用 watch 使用 watch 允许我们执行异步操作，（注意防抖）")]),t._v(" "),a("h2",{attrs:{id:"解释-mvvm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#解释-mvvm"}},[t._v("#")]),t._v(" 解释 mvvm")]),t._v(" "),a("h2",{attrs:{id:"vue-的双向数据绑定的实现-响应式原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-的双向数据绑定的实现-响应式原理"}},[t._v("#")]),t._v(" vue 的双向数据绑定的实现，响应式原理")]),t._v(" "),a("p",[t._v("双向数据绑定是通过数据劫持结合发布订阅者模式实现的，数据劫持是通过 Object.defineProperty 为属性添加 getter 和 setter 对数据进行劫持，在数据变动时发布消息给订阅者，触发响应的监听回调。")]),t._v(" "),a("h2",{attrs:{id:"vue-组件的-data-为什么必须是函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-组件的-data-为什么必须是函数"}},[t._v("#")]),t._v(" Vue 组件的 data 为什么必须是函数")]),t._v(" "),a("p",[t._v("因为组件是可以复用的,JS 里对象是引用关系,如果组件 data 是一个对象,那么子组件中的 data 属性值会互相污染,产生副作用。")]),t._v(" "),a("p",[t._v("所以一个组件的 data 选项必须是一个函数,因此每个实例可以维护一份被返回对象的独立的拷贝。new Vue 的实例是不会被复用的,因此不存在以上问题。")])])}),[],!1,null,null,null);e.default=s.exports}}]);