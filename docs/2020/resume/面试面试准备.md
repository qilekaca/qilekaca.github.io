<!-- ---
title: 面试准备
date: 2020-09-10
sidebar: "auto"
categories:
  - 前端
tags:
  - 面试
publish: false
--- -->

## 深浅拷贝

```js
// 数组的深浅拷贝 slice contact
const a = [1,2,3]
const b = a.slice()
const c = a.contact()
// 对象的浅拷贝
const a = {name: 'zhang', age: 12}
const b = {...a}
// 简单的浅拷贝
const shallClone = target => {
  if (typeof target === 'object' && target !== null) {
    const clone = Array.isArray(target) ? [] : {}
    for (let prop in target) {
      if(target.hasOwnProperty(prop)) {
        clone[prop] = target[prop]
      }
    }
    return clone
  } else {
    return target
  }
}
//
function deepClone(target)  {
  if (target === null) return null;
  if (typeof target !== 'object') return target;

  const cloneTarget = Array.isArray(target) ? [] : {};
  for (let prop in target) {
    if (target.hasOwnProperty(prop)) {
      cloneTarget[prop] = deepClone(target[prop]);
    }
  }
  return cloneTarget;
}
// 简单的深拷贝
const b = JSON.parse(JSON.stringify(a))
// 复杂深拷贝
function cloneDeep(target,map = new WeakMap()) {
  if(typeOf taret ==='object'){
     let cloneTarget = Array.isArray(target) ? [] : {};

     if(map.get(target)) {
        return target;
    }
     map.set(target, cloneTarget);
     for(const key in target){
        cloneTarget[key] = cloneDeep(target[key], map);
     }
     return cloneTarget
  }else{
       return target
  }

}
// 添加正则和时间
function deepClone(obj, map = new WeakMap()) {
    if (obj instanceof RegExp) return new RegExp(obj);
    if (obj instanceof Date) return new Date(obj);

    if (obj == null || typeof obj != 'object') return obj;
    if (map.has(obj)) {
        return map.get(obj);
    }
    let t = new obj.constructor();
    map.set(obj, t);
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            t[key] = deepClone(obj[key], map);
        }
    }
    return t;
}
//测试用例
let obj = {
    a: 1,
    b: {
        c: 2,
        d: 3
    },
    d: new RegExp(/^\s+|\s$/g)
}

let clone_obj = deepClone(obj)
obj.d = /^\s|[0-9]+$/g
console.log(clone_obj)
console.log(obj)

```

## 创建 ajax

```js
```

## Promise 的使用

- .then
- .catch
- .finally
- Promise.resolve()
- Promise.reject()
- Promise.race()
- Promise.all()

## new 一个对象的时候发生了什么

1. 创建一个空对象 `let obj = {}`
2. 让构造函数中的 this 指向新的对象，并执行构造函数的函数体`let result = Person.call(obj);`
3. 设置新对象的**proto**属性指向构造函数的原型对象`obj.__proto__ = Person.prototype;`
4. 判断构造函数的返回值类型，如果是值类型，则返回新对象。如果是引用类型，就返回这个引用类型的对象

## 数组去重

## 继承

## 防抖和节流

防抖可以用在输入框，防止用户多次提交表单，简单的理解就是在时间触发后 n 秒在执行回调，如果在这 n 秒中事件又被触发，则重新计时。
节流可用在监听滚动事件的时候。原来每秒执行 10 次回调变为每秒执行 2 次回调。

```js
// 函数防抖的实现
function debounce(fn, wait) {
  var timer = null;

  return function() {
    var context = this,
      args = arguments;

    // 如果此时存在定时器的话，则取消之前的定时器重新记时
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }

    // 设置定时器，使事件间隔指定事件后执行
    timer = setTimeout(() => {
      fn.apply(context, args);
    }, wait);
  };
}

// 函数节流的实现;
function throttle(fn, delay) {
  var preTime = Date.now();

  return function() {
    var context = this,
      args = arguments,
      nowTime = Date.now();

    // 如果两次时间间隔超过了指定时间，则执行函数。
    if (nowTime - preTime >= delay) {
      preTime = Date.now();
      return fn.apply(context, args);
    }
  };
}
```

## MVC MVVM MVP

MVVM 最早由微软提出来，它借鉴了桌面应用程序的 MVC 思想，在前端页面中，把 Model 用纯 JavaScript 对象表示，View 负责显示，两者做到了最大限度的分离，把 Model 和 View 关联起来的就是 ViewModel。
ViewModel 负责把 Model 的数据同步到 View 显示出来，还负责把 View 的修改同步回 Model
View 和 Model 之间的同步工作完全是自动的，无需人为干涉（由 viewModel 完成，在这里指 VUE）
因此开发者只需关注业务逻辑，不需要手动操作 DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理
MVVM 的设计思想：关注 Model 的变化，让 MVVM 框架去自动更新 DOM 的状态，从而把开发者从操作 DOM 的繁琐步骤中解脱出来！
MVC 和 MVP 的关系
MVP 是从经典的模式 MVC 演变而来，它们的基本思想有相通的地方：Controller/Presenter 负责逻辑的处理，Model 提供数 据，View 负责显示。作为一种新的模式，MVP 与 MVC 有着一个重大的区别：在 MVP 中 View 并不直接使用 Model，它们之间的通信是通过 Presenter (MVC 中的 Controller)来进行的，所有的交互都发生在 Presenter 内部，而在 MVC 中 View 会直接从 Model 中读取数据而不是通过 Controller。
MVVM 和 MVP 的关系
而 MVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。 唯一的区别是，它采用双向绑定（data-binding）：View 的变动，自动反映在 ViewModel，反之亦然。这样开发者就不用处理接收事件和 View 更新的工作，框架已经帮你做好了。
